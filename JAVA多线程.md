### 1.线程概述

#### 1.1 线程相关概念

- 线程就是独立的执行路径
- 在线程运行时，即使没有自己创建线程，后台也会有多个线程，如主线程、gc线程
- main()称之为主线程，为系统的入口，用于执行整个程序
- 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的
- 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制
- 线程会带来额外的开销，如CPU调度时间，并发控制开销
- 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致

#### 1.2 线程的三种创建方式

**Thread class：继承Thread类**

- 子类继承Thread类具备多线程能力
- 启动线程：子类对象.start()
- 不建议使用：避免OPP单继承局限性

**Runnable接口：实现Runnable接口**

- 实现接口Runnable具有多线程能力
- 启动线程：传入目标对象+Thread对象.start()
- 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用

**Callable接口：实现Callable接口**

#### 1.3 线程的常用方法

##### 1.3.1 currentThread()

- Thread.currentThread()方法可以获取当前线程。
- Java中的任何一段代码都是执行在某个线程中的。执行当前代码的线程就是当前线程。
- 同一段代码可能被不同的线程执行，因此当前线程是相对的，Thread.currentThread()方法的返回值是在代码实际运行时候的线程对象。

##### 1.3.2 setName()/getName()

- thread.setName(线程名称)，设置线程名称
- thread.getName()返回线程名称
- 通过设置线程名称，有助于程序调试，提高程序的可读性，建议为每个线程都设置一个能够体现线程功能的名称。

##### 1.3.3 isAlive()

- thread.iaAlive()判断当前线程是否处于活动状态。
- 活动状态就是线程已启动并且尚未终止。

##### 1.3.4 sleep()

- Thread.sleep(mills);让当前线程休眠指定的毫秒数
- 当前线程指的是Thread.currentThread()返回的线程

##### 1.3.5 getId()

- thread.getId() 可以获得线程的唯一标识
- 注意：某个编号的线程运行结束后，该编号可能被后续创建的线程使用
- 重启的JVM后，同一个线程的编号可能不一样

##### 1.3.6 yieId()

- Thread.yieId()；方法的作用是放弃当前的CPU资源

##### 1.3.7 setPriority()

- thread.setPriority()；设置线程的优先级
- Java线程的优先级取值范围是 1~10，如果超出这个范围会抛出异常。
- 在操作系统中，优先级较高的线程获得的CPU资源越多
- 线程优先级本质上是只给线程调度器一个提示信息，以便于调度器决定先调度那些线程。注意不能保证优先级高的线程先运行。
- Java优先级设置不当或者滥用可能会导致某些线程永远无法得到运行，即产生了线程饥饿
- 线程的优先级并不是设置的越高越好，一般情况下使用普通的优先级即可
- 线程优先级具有继承性，在A线程中创建了B线程，则B线程的优先级与A线程是一样的

##### 1.3.8 interrupt()

- 中断线程
- 调用interrupt()仅仅是在当前线程打一个停止标志，并不是真正的停止线程

##### 1.3.9 setDaemon()

- Java中的线程分为用户线程与守护线程
- 守护线程是为其他线程提供服务的线程，如垃圾回收器(GC)就是一个典型守护线程
- 守护线程不能单独运行，当JVM中没有其他用户线程，只有守护线程时守护线程会自动销毁，JVM会退出。

#### 1.4 线程的生命周期

- 线程的生命周期是线程对象的生老病死，即线程的状态

- 线程的生命周期可以i通过 getState()方法获得，线程的状态是Thread.State 枚举类型定义的，有以下几种：
  - NEW，新建状态，创建了线程对象，在调用start()启动前的状态；
  - RUNNABLE，可运行状态。它是一个复合状态，包含：READY和RUNNING两个状态。READY状态该线程可以被线程调度器进行调度使它处于 RUNNING 状态，RUNNING 状态表示该线程正在执行。Thread.yieId()方法可以把线程由 RUNNING 状态转换为 READY 状态。
  - BLOCKED 阻塞状态。线程发起阻塞的 I/O 操作，或者申请由其他线程占用的独占资源，线程会转换为 BLOCKED 阻塞状态。处于阻塞状态的线程不会占用 CPU 资源。当阻塞 I/O 操作执行完，或者线程获得了其申请的资源，线程可转换为 RUNNABLE。
  - WAITING 等待状态。线程执行了 object.wait(),thread.join()方法会把线程转换为 WAITING 等待状态，执行 object.notify()方法，或者加入的线程执行完毕，当前线程会转换为 RUNNABLE 状态。
  - TIMED_WAITING 状态，与 WAITING 状态类似，都是等待状态。区别在于处于该状态的线程不会无限的等待，如果线程没有在指定的时间范围内完成期望的操作，该线程自动转换为 RUNNABLE。
  - TERMINATED终止状态，线程结束处于终止状态

  

  #### 1.5 多线程编程存在的问题与风险

  **优势**

  - 提高系统的吞吐率。多线程可以使一个进程有多个并发的操作
  - 提高响应性。Web服务器会采用一些专门的线程负责用户的请求处理，缩短了用户的等待时间
  - 充分利用多核处理器资源。通过多线程可以充分的利用CPU资源

  **问题与风险**

  - 线程安全问题。多线程共享数据时，如果没有采取正确的并发访问控制措施，就可能会产生数据一致性问题，如读取脏数据(过期的数据)，如丢失数据更新。
  - 线程活性问题。由于程序自身的缺陷，或者由资源的稀缺性导致线程一直处理非 RUNNABLE 状态。常见的活性故障有以下几种：
    - 死锁(Deadlock)。类似鹬蚌相争
    - 锁死(Lockout)
    - 活锁(Livelock)。小猫咬自己尾巴
    - 饥饿(Starvation)
  - 上下文切换(Context Switch)。处理器从执行一个线程切换到执行另一个线程
  - 可靠性。可能会由一个线程导致JVM 意外终止，其他的线程也无法执行

### 2.线程安全问题

​	非线程安全主要是指多个线程对同一个对象的实例变量进行操作时，出现值被更改，值不同步的情况。

​	线程安全表现为三个方面：原子性、可见性、有序性

#### 2.1 原子性

​	原子(Atomic)就是不可分割的意思。原子操作的不可分割有两层含义：

- 访问(读、写)某个共享变量的操作从其他线程来看，该操作要么已经执行完毕，要么
- 尚未发生，即其他线程中看不到当前操作的中间结果
- 访问同一组共享变量的原子操作是不能够交错的

​    Java有两种方式实现原子性：一种是使用锁；另一种利用处理器的CAS(Compare and Swap)指令。

​	锁具有排它性，保证共享变量在某一个时刻只能被一个线程访问。

​	CAS指令直接在硬件(处理器和内存)层次上实现，硬件锁。

#### 2.2 可见性

​	在多线程环境中，一个线程对某个共享变量进行更新之后，后续其他的线程可能无法立即读到这个更新的结果，这就是线程安全中的 **可见性**(visibility)。

​	如果一个线程对共享变量更新后，后续访问该变量的其他线程可以读到更新结果，称这个线程对共享变量的更新对其他线程可见，否则成这个线程对共享变量的更新对其他线程不可见。

​	多线程程序因为可见性可能会导致其他线程读取到了旧数据。

#### 2.3 有序性

##### 2.3.1 重排序

​	有序性(Ordering)是指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另外一个处理器运行的其它线程看来是乱序的(Out of order)。

​	乱序是指内存访问操作的顺序看起来发生了变化。

​	在多核处理器的环境下，编写的顺序结构，这种操作执行的顺序可能是没有保证的：

- 编译器可能会改变两个操作的先后顺序
- 处理器可能不会按照目标代码的顺序执行

​    这种一个处理器上执行的多个操作，在其它处理器看来它的顺序与目标代码指定的顺序可能不一样，这种现象称为重排序。

​	重排序是对内存访问有序操作的一种优化，可以在不影响单线程程序正确的情况下提升程序的性能。但是可能对多线程程序的正确性产生影响，即可能导致线程安全问题。

​	重排序与可见性问题类似，不是必然出现的。

​	与内存操作顺序有关的概念：

- 源代码顺序，就是源码中指定的内存访问顺序
- 程序顺序，处理器上运行的目标代码所制定的内存访问顺序
- 执行顺序，内存访问操作在处理器上的实际执行顺序
- 感知顺序，给定处理器所感知到的该处理器及其它处理器的内存访问操作的顺序

​    可以把重排序分为指令重排序与存储子系统重排序两种

- 指令重排序主要是由 JIT 编译器、处理器引起的，指程序顺序与执行顺序不一样
- 存储子系统重排序是由高速缓存，写缓冲器引起的，感知顺序与执行顺序不一致

##### 2.3.2 指令重排序

​	**指令顺序发生了变化**

​	在源码顺序与程序顺序不一致，或者程序顺序与执行顺序不一致的情况下，就说发生了指令重排序(Instruction Reorder)。

​	指令重排是一种动作，确实对指令的顺序做了调整，重排序对象的指令。

​	javac 编译器一般不会执行指令重排序，但是 JIT 编译器可能执行指令重排序。

​	处理器也可能执行指令重排序，使得执行顺序与程序顺序不一致。

​	指令重排不会对单线程程序的结果正确性产生影响，但是可能导致多线程程序出现非预期的结果。

##### 2.3.3 存储子系统重排序

​	**指令顺序没有发生变化**

​	存储子系统是指写缓冲器与高速缓存。

- 高速缓存(Cache)是 CPU 中为了匹配与主内存处理速度不匹配而设计的一个高速缓存
- 写缓冲器(Store buffer, Write buffer)用来提高写高速缓存操作的效率

​    即使处理器严格按照程序顺序执行两个内存访问操作，在存储子系统的作用下，其他处理器对这两个操作的**感知顺序与程序顺序不一致**，即这两个操作的顺序看起来像是发生了变化，这种现象称为存储子系统重排序。

​	存储子系统重排序并没有真正的对指令执行顺序进行调整，而是造成了一种指令执行顺序被调整的现象。

​	从处理器角度看，都内存就是从指定的 RAM 地址中加载数据到寄存器，称为 Load 操作；写内存就是把数据存储到指定地址表示的 RAM 存储单元中，称为 Store 操作。内存重排序有以下四种可能：

- LoadLoad 重排序，一个处理器先后执行两个读操作 L1 和 L2 ，其他处理器对两个内存操作的感知顺序可能书 L2 -> L1
- StoreStore重排序，一个处理器先后执行两个写操作 W1 和 W2 ，其他处理器对两个内存操作的感知顺序可能书 W2-> W1 
- LoadStore 重排序，一个处理器先执行读操作 L1 再执行写操作 W1 ，其他处理器对两个内存操作的感知顺序可能书 W1 -> L1 
- StoreLoad 重排序，一个处理器先执行写操作 W1 再执行读操作 L1 ，其他处理器对两个内存操作的感知顺序可能书 L1 -> W1 

​    内存重排序与具体的处理器微架构有关，不同的架构的处理器所允许的内存重排序不同。

​	内存重排序可能会导致线程安全问题。

##### 2.3.4 貌似串行语义

​	JIT 编译器、处理器、存储子系统是按照一定的规则对指令、内存操作的结果进行重排序，给单线程程序造成一种假象---指令是按照源码的顺序执行的。这种假象称为貌似串行语义。并不能保证多线程环境程序的正确性。

​	为了保证貌似串行语义，有数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才会被重排序。如果两个操作(指令)访问同一个变量，且其中一个操作(指令)为写操作，那么这两个操作之间就存在数据依赖关系(Data dependency)。

​	存在控制依赖关系的语句允许重排。一条语句(指令)的执行结果会决定另一条语句(指令)能否被执行，这两条语句(指令)存在控制依赖关系(Control Dependency)

##### 2.3.5 保证内存访问的顺序性

​	可以使用 volatile 关键字，synchronized 关键字实现有序性，也就是感知顺序和源码顺序一致。

### 3、线程同步

#### 3.1 线程同步机制简介

​	线程同步机制是一套用于协调线程之间的数据访问的机制。该机制可以保障线程安全。

​	Java平台提供的线程同步机制包括：锁、volatile 关键字、final 关键字、static 关键字，以及相关的 API，如 Object.wait()、Object.notify()等

#### 3.2 锁概述

​	线程安全问题产生的前提是多个线程并发访问共享数据。

​	将多个线程对共享数据的并发访问转换为串行访问，即一个共享数据一次只能被一个线程访问。锁就是复用这种思路来保障线程安全。

​	锁(Lock)可以理解为对共享数据进行保护的一个许可证。对于同一个许可证保护的共享数据来说，任何线程想要访问这些共享数据必须先持有许可证，一个线程只有在持有许可证的情况下才能对这些共享数据进行访问；并且一个许可证一次只能被一个线程持有；许可证线程在结束对共享数据的访问后必须释放其持有的许可证。

​	一个线程在访问共享数据前必须先获得锁；获得锁的线程成为锁的持有线程；一个锁一次只能被一个线程持有。锁的持有线程在获得锁之后和释放锁之前这段时间所执行的代码称为临界区(Critical)。

​	锁具有排它性(Exclusive)，即一个锁一次只能被一个线程持有(Mutex).

​	JVM把锁分为内部锁和显示锁。内部锁通过 synchronized 关键字实现；显示锁通过 java.concurrent.locks.Lock 实现的接口类。

##### 3.2.1 锁的作用

​	锁可以实现对共享数据的安全访问。保障线程的原子性、可见性与有序性。

​	锁是通过互斥保证**原子性**。一个锁只能被一个线程持有，这就保证临界区代码一次只能被一个线程执行。使得临界区代码所执行的操作自然而然的具有不可分割的特性，即具备了原子性。

​	**可见性**的保证是通过写线程冲刷处理器的缓存和读线程刷新处理器缓存这两个动作实现的。在 Java 平台中，锁的获得隐含着刷新处理器缓存的动作，锁的释放隐含着冲刷处理器缓存的动作。

​	锁能够保障**有序性**。写线程在临界区所执行的在读线程所执行的临界区看来完全像是按照源码顺序执行的。

​	使用锁保证线程的安全性，必须满足以下条件：

- 这些线程在访问共享数据时必须使用同一个锁
- 即使是读取共享数据的线程也需要使用同步锁

##### 3.2.2 锁相关概念

1）**可重入性(Renntrancy)**

​	一个线程持有该锁的时候能再次(多次)申请该锁。如果一个线程持有一个锁的时候还能够继续成功申请该锁，称该锁是可重入的，否则就成该锁为不可重入。

2）**锁的争用与调度**

​	Java 平台中内部锁属于非公平锁，显示 Lock 锁即支持公平锁又支持非公平锁。

3）**锁的粒度**

​	一个锁可以保护的共享数据的数量大小称为**锁的粒度**。

​	锁保护共享数据量大，称该锁的粒度粗，否则就称该锁的粒度细。

​	锁的力度过粗会导致线程在申请锁时会进行不必要的等待；锁的粒度过细会增加锁调度的开销。

#### 3.3 内部锁：synchronized 关键字





