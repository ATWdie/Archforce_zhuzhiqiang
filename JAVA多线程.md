## 线程

### 核心概念

- 线程就是独立的执行路径
- 在线程运行时，即使没有自己创建线程，后台也会有多个线程，如主线程、gc线程
- main()称之为主线程，为系统的入口，用于执行整个程序
- 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的
- 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制
- 线程会带来额外的开销，如CPU调度时间，并发控制开销
- 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致

#### 1、线程的三种创建方式

**Thread class：继承Thread类**

- 子类继承Thread类具备多线程能力
- 启动线程：子类对象.start()
- 不建议使用：避免OPP单继承局限性

**Runnable接口：实现Runnable接口**

- 实现接口Runnable具有多线程能力
- 启动线程：传入目标对象+Thread对象.start()
- 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用

**Callable接口：实现Callable接口**

#### 2、线程的五个状态

- 新生
- 就绪
- 运行 -->阻塞
- 死亡

#### 3、守护(daemon)线程

- 线程分为用户线程和守护线程
- 虚拟机必须确保**用户线程**执行完毕
- 虚拟机不用等待**守护线程**执行完毕
- 如，后台记录操作日志，监控内存，垃圾回收等待...

#### 4、线程同步

- 并发：同一个线程被多个对象同时操作
- 队列+锁 -->保证线程同步的安全性

#### 5、同步方法

- Synchronized 关键字包含两种用法：synchronized 方法和 synchronized 块
- synchronized 方法控制对 “对象” 的访问，每个对象对应一把锁，每个 synchronized 方法都必须获得该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。
- **缺陷**：若将一个大的方法声明为 synchronized 将会影响效率

#### 6、死锁

​	多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，从而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有**两个以上对象的锁**时，就可能会发生**死锁**的问题。

**死锁产生的条件**

1. **互斥条件**：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只被一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直到占有资源的进程用完释放。
2. **请求和保持条件**：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占用，此时请求进程阻塞，但又对自己已获得的资源保持不放。
3. **不剥夺条件**：指进程已获得的资源，在使用结束之前，不能被剥夺，只能在使用结束之后自己释放。
4. **环路等待条件**：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，…，Pn}中的P0 正在等待一个P1占用的资源，P1正在等待P2占用的资源，……，Pn正在等待P0占用的资源。

#### 7、Lock(锁)

- 从 JDK5 开始，JAVA 提供更强大的线程同步机制——通过显式定义同步锁对象来实现同步，同步锁对象使用 Lock 对象充当。
- java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock 对象。

**Lock 与 Synchronized**

- Lock 是显式锁，需要手动开启和关闭，synchronized 是隐式锁，出了作用域自动释放
- Lock 只有代码块锁，synchronized 有代码块锁和方法锁
- 使用 Lock 锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多子类）
- 使用顺序：Lock > 同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方法体之外）

#### 8、线程协作









